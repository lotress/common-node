// Generated by CoffeeScript 2.7.0
var BinaryHeap, None, Test, _, allAwait, deadline, delay, genLog, genWrap, identity, isFunction, isGenerator, logError, logInfo, newMessageArray, newPool, raceAwait, retry, sequence, tco;

Test = require('./testFramework');

_ = require('./common');

({identity, None, isFunction, delay, deadline, retry, allAwait, raceAwait, sequence, isGenerator, tco, BinaryHeap, genWrap, genLog, logInfo, logError, newMessageArray, newPool} = _);

logInfo = genLog(2);

Test('lazy Monad')(({assert, assertSeq}) => {
  var f, r, res, seq, status;
  status = 1;
  seq = 3;
  res = [];
  f = _.M((x) => {
    return x + 1;
  }).then((x) => {
    assertSeq(++seq);
    return x;
  }).then((x) => {
    return assert(x === 2);
  }).then(() => {
    return assert(status === 2);
  }).then(() => {
    throw new Error('wrong');
  }).then(() => {
    return assert(false);
  }).catch((e) => {
    return assert(e.message === 'wrong');
  }).then(() => {
    return assertSeq(++seq);
  });
  res.push(assertSeq(1));
  res.push(f(1));
  res.push(assertSeq(2));
  status = 2;
  r = f(1).then(() => {
    return assertSeq(2e308);
  });
  res.push(r);
  res.push(assertSeq(3));
  return Promise.all(res);
});

Test('Monad handler type check')((report) => {
  var e, f;
  try {
    f = _.M((x) => {
      return x + 1;
    }).then(null, logError).then(Promise.resolve()).then(() => {
      throw new Error('wrong');
    });
    return f(1);
  } catch (error) {
    e = error;
    return report.assert(e instanceof TypeError);
  }
});

Test('Immutable Monad')((report) => {
  var f, g, h;
  f = _.M(identity);
  g = f.then(() => {
    return 1;
  });
  h = f.then(() => {
    return 2;
  });
  return Promise.all([f, g, h].map((fn, i) => {
    return fn(i).then((x) => {
      return report.assert(x === i);
    });
  }));
});

Test('identity')((report) => {
  var x;
  x = {};
  return Promise.all([report.assert(x === identity.apply(this, [x, 1])), report.assert(void 0 === identity())]);
});

Test('None')((report) => {
  var x;
  x = {};
  return Promise.all([report.assert(void 0 === None.apply(this, [x, {}])), report.assert(void 0 === None())]);
});

Test('wait with delay and deadline')((report) => {
  var f, interval, start, timing;
  start = Date.now();
  timing = (time) => {
    return delay(time)();
  };
  interval = (k) => {
    return (time) => {
      if (time.message != null) {
        time = time.message;
      }
      report.assert(Date.now() - start >= time * k);
      return time;
    };
  };
  f = _.M(timing).then(interval(1)).then(timing).then(interval(2)).then((time) => {
    return deadline(time)();
  }).catch(interval(3));
  return f(100);
});

Test('death race')(({assert}) => {
  var f, life;
  life = 1000;
  f = (time) => {
    var a, g, h, start;
    a = allAwait([identity, delay(time), delay(time * 2)]);
    g = _.M(a).then(None).then(a).then(None).then(a).then(() => {
      return assert(Date.now() - start >= time * 6);
    });
    h = raceAwait([g, deadline(life)]);
    logInfo(`race began with time interval ${time}ms`);
    start = Date.now();
    return h().then(() => {
      assert(Date.now() - start < life);
      return logInfo(`after ${Date.now() - start}ms, should resolve when time interval < ${life} / 6`);
    }).catch((e) => {
      e = +e.message;
      assert(e === life);
      assert(Date.now() - start >= e);
      return logInfo(`after ${Date.now() - start}ms, should reject when time interval > ${e} / 6`);
    });
  };
  return Promise.all([f(100), f(200)]);
});

Test('retry')(({assert}) => {
  var f, g;
  f = ((times) => {
    return (count = 0) => {
      return () => {
        count += 1;
        if (count < times) {
          throw new Error(`${count} < ${times}`);
        }
        return count;
      };
    };
  })(3);
  g = retry(f())(3);
  return Promise.all([
    retry(f())(2)().then(() => {
      return assert(false);
    }).catch((e) => {
      return assert(e.message === '2 < 3');
    }),
    g().then((r) => {
      return assert(r === 3);
    }).catch(() => {
      return assert(false);
    }),
    delay(1000)().then(g).then((r) => {
      return assert(r === 4);
    }).catch(() => {
      return assert(false);
    })
  ]);
});

Test('sequence')(async({assert, assertSeq}) => {
  var a, f, g, number, s;
  number = function*() {
    var k, n;
    n = 1;
    k = 1;
    while (true) {
      k = (yield n + k);
    }
  };
  f = function(x) {
    if (x < 5) {
      assertSeq(x);
      return x;
    } else {
      return void 0;
    }
  };
  g = function(x) {
    return delay(1000)().then(() => {
      return f(x);
    });
  };
  s = sequence(g)(number());
  return Promise.all([
    assertSeq(0),
    a = (await s),
    assert(a.every((x,
    i) => {
      return x === i + 2;
    }))
  ]);
});

Test('isGenerator')((report) => {
  var number;
  number = function*() {
    var n;
    n = 1;
    while (true) {
      yield n++;
    }
  };
  return Promise.all([report.assert(!isGenerator(number)), report.assert(isGenerator(number()))]);
});

Test('tail call optimization')(async({assert}) => {
  var count, countFn, countR, e;
  countFn = function*(n, res = 0) {
    if (n <= 1) {
      return (yield res + n);
    } else {
      return (yield countFn(n - 1, res + 1));
    }
  };
  countR = (n) => {
    if (n <= 1) {
      return n;
    } else {
      return 1 + countR(n - 1);
    }
  };
  try {
    tco(identity);
    await assert(false);
  } catch (error) {
    e = error;
    await assert(e.name === 'TypeError');
  }
  count = tco(countFn);
  await assert(count(1e7));
  try {
    countR(1e7);
    return (await assert(false));
  } catch (error) {
    e = error;
    return (await assert(e.name === 'RangeError'));
  }
});

Test('Priority Queue')(({assert}) => {
  var N, compare, data, i, queue, res1, resA;
  queue = [2, 1, 4].reduce(((queue, x) => {
    return queue.push(x);
  }), new BinaryHeap({
    simple: true
  }));
  assert(isFunction(queue.push));
  assert(isFunction(queue.peek));
  assert(isFunction(queue.pop));
  queue.push(3);
  assert(queue.peek() === 1);
  assert([1, 2, 3, 4].reduce(((flag, x) => {
    return flag && x === queue.pop();
  }), true));
  N = 1e6;
  data = (function() {
    var j, ref, results;
    results = [];
    for (i = j = 1, ref = N; (1 <= ref ? j <= ref : j >= ref); i = 1 <= ref ? ++j : --j) {
      results.push({
        v: Math.random()
      });
    }
    return results;
  })();
  compare = (a, b) => {
    return a.v - b.v;
  };
  queue = new BinaryHeap();
  console.time(`Heapsort ${N}`);
  data.forEach((x) => {
    return queue.push(x.v, x);
  });
  res1 = (function() {
    var j, ref, results;
    results = [];
    for (i = j = 1, ref = N; (1 <= ref ? j <= ref : j >= ref); i = 1 <= ref ? ++j : --j) {
      results.push(queue.pop());
    }
    return results;
  })();
  console.timeEnd(`Heapsort ${N}`);
  console.time(`Array sort ${N}`);
  resA = data.sort(compare);
  console.timeEnd(`Array sort ${N}`);
  return assert(resA.every((item, i) => {
    return item === res1[i][1];
  }));
});

Test('Wrapper Generator')(({assert}) => {
  var e, f, r, rr, w;
  f = function(x) {
    this.x = x.length;
  };
  w = genWrap(f);
  r = w('aaa');
  rr = w(r);
  assert(r.x === 3);
  assert(r === rr);
  try {
    genWrap('wrong');
    return assert(false);
  } catch (error) {
    e = error;
    return assert(e instanceof TypeError);
  }
});

Test('Message Array')(({assert}) => {
  var e, i, id, item, items, j, newItem, peek, popItem, t;
  items = [];
  [newItem, popItem, peek] = newMessageArray(2, items);
  for (i = j = 1; j <= 4; i = ++j) {
    newItem();
  }
  id = items[2].id;
  t = peek(id);
  assert(items[2] === t);
  item = popItem(id);
  assert(item.id === id);
  assert(t.id === id);
  assert(items[2] === void 0);
  item = popItem(id);
  assert(item === void 0);
  item = newItem();
  assert((item.id & 3) === 2);
  assert(item.id > 2);
  try {
    newItem();
    return assert(false);
  } catch (error) {
    e = error;
    return assert(e.message === 'Full');
  }
});

Test('Pool')(async({assert, idle}) => {
  var ac, acquire, c, d, f, pool, release, s, start, timeout, times;
  pool = [1, 2, 3];
  s = new Set();
  [ac, release] = newPool(pool);
  acquire = ((g) => {
    return async() => {
      return ((await g())).value;
    };
  })(((o) => {
    return o.next.bind(o);
  })(ac()));
  c = 0;
  timeout = 20;
  d = delay(timeout);
  times = 99;
  f = async() => {
    var v;
    if (c > times) {
      return;
    }
    c += 1;
    v = (await acquire());
    assert(!s.has(v));
    s.add(v);
    return d().then(function() {
      assert(s.has(v));
      s.delete(v);
      release(v);
      return f();
    });
  };
  await idle();
  start = Date.now();
  return Promise.all([f(), f(), f()]).then(() => {
    return Date.now() - start;
  }).then((elapse) => {
    var ref;
    return assert((elapse * 3 >= (ref = timeout * times) && ref > elapse * 2));
  });
});

Test('Pool with timeout')(({assert}) => {
  var ac, acquire, c, f, pool, release, s;
  pool = [1, 2, 3];
  s = new Set(pool);
  [ac, release] = newPool(pool, 10, true);
  acquire = ((g) => {
    return async() => {
      return ((await g())).value;
    };
  })(((o) => {
    return o.next.bind(o);
  })(ac()));
  c = 0;
  f = async() => {
    var res;
    res = (await acquire());
    if (res instanceof Error) {
      c = 1;
      assert(pool.length === 0);
      assert(+res.message === 10);
      return;
    }
    await delay(20)();
    assert(s.has(res));
    s.delete(res);
    return release(res);
  };
  return Promise.all((function() {
    var j, results;
    results = [];
    for (_ = j = 1; j <= 4; _ = ++j) {
      results.push(f());
    }
    return results;
  })()).then(() => {
    assert(s.size === 0);
    return assert(c === 1);
  });
});

//# sourceMappingURL=test.js.map
