// Generated by CoffeeScript 2.3.0

/* eslint no-console: 0 */
var None,
  allAwait,
  allPromise,
  apply,
  bindObject,
  concatArr,
  deadline,
  delay,
  expandApply,
  firstElement,
  flatArray,
  flatObject,
  genLog,
  getFullPath,
  identity,
  invokeAsync,
  invokePromises,
  logError,
  logInfo,
  logLevel,
  makeFrame,
  mapArr,
  pall,
  pushMap,
  raceAwait,
  racePromise,
  retry,
  zipApplyArr

concatArr = (res, arr) => {
  return res.concat(arr)
}

flatArray = arr => {
  return arr.reduce(concatArr, [])
}

flatObject = o => {
  var key, res
  res = {}
  for (key in o) {
    if (o[key] != null && o.hasOwnProperty(key)) {
      if (typeof o[key] === 'object' && !Array.isArray(o[key])) {
        Object.assign(res, flatObject(o[key]))
      } else if (res[key] == null) {
        res[key] = o[key]
      }
    }
  }
  return res
}

identity = x => {
  return x
}

None = () => {
  return void 0
}

bindObject = (o, name) => {
  return o[name].bind(o)
}

allPromise = bindObject(Promise, 'all')

racePromise = bindObject(Promise, 'race')

invokeAsync = func => {
  return async function (...args) {
    return await func(...args)
  }
}

expandApply = func => {
  return arr => {
    return func(...arr)
  }
}

mapArr = func => {
  return arr => {
    return arr.map(func)
  }
}

zipApplyArr = a1 => {
  return a2 => {
    return a1.map((f, i) => {
      return f(a2[i])
    })
  }
}

invokePromises = predicate => {
  return funcs => {
    var fz, g
    g = f => {
      return expandApply(invokeAsync(f))
    }
    fz = zipApplyArr(mapArr(g)(funcs))
    return arr => {
      return predicate(fz(arr))
    }
  }
}

allAwait = invokePromises(allPromise)

raceAwait = invokePromises(racePromise)

apply = func => {
  var f
  f = expandApply(invokeAsync(func))
  return mapFunc => {
    return mapFunc(f)
  }
}

makeFrame = keys => {
  return values => {
    var o
    o = {}
    keys.forEach((key, i) => {
      if (values[i] !== void 0) {
        return (o[key] = values[i])
      }
    })
    return o
  }
}

firstElement = iterable => {
  return iterable[Symbol.iterator]().next().value
}

pall = fn => {
  return items => {
    return allPromise(items.map(fn))
  }
}

pushMap = map => {
  return item => {
    return key => {
      var c
      c = map.get(key)
      if (c == null) {
        c = []
      }
      c.push(item)
      return map.set(key, c)
    }
  }
}

delay = timeout => {
  return () => {
    return new Promise(resolve => {
      return setTimeout(() => {
        return resolve(timeout)
      }, timeout)
    })
  }
}

deadline = timeout => {
  return () => {
    return new Promise((resolve, reject) => {
      return setTimeout(() => {
        return reject(timeout)
      }, timeout)
    })
  }
}

retry = f => {
  return (count = 1) => {
    return (...args) => {
      var g
      return (g = e => {
        if (count--) {
          return Promise.resolve(f(...args)).catch(g)
        } else {
          return Promise.reject(e)
        }
      })(void 0)
    }
  }
}

logLevel = 2

genLog = (logLevel => {
  return level => {
    return func => {
      if (logLevel > level) {
        return func
      } else {
        return None
      }
    }
  }
})(logLevel)

logInfo = genLog(1)(bindObject(console, 'log'))

logError = genLog(-1)(bindObject(console, 'error'))

getFullPath = directory => {
  var p, path
  path = require('path')
  p = path.join(process.cwd(), directory)
  return name => {
    return path.join(p, name)
  }
}

module.exports = {
  concatArr,
  flatArray,
  flatObject,
  identity,
  None,
  invokeAsync,
  allAwait,
  raceAwait,
  delay,
  deadline,
  retry,
  makeFrame,
  firstElement,
  pall,
  pushMap,
  logInfo,
  logError,
  getFullPath
}

// # sourceMappingURL=common.js.map
