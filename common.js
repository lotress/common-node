// Generated by CoffeeScript 2.3.0

/*eslint no-console: 0*/
var M, None, allAwait, allPromise, apply, bindObject, concatArr, deadline, delay, expandApply, firstElement, flatArray, flatObject, genLog, getFullPath, getIterator, identity, invokeAsync, invokePromises, isFunction, isIterable, isMultiIterable, isObject, isSymmetry, isType, logError, logInfo, logLevel, makeFrame, mapArr, mapList, pall, pushMap, raceAwait, racePromise, retry, zipApplyArr;

isType = (type) => {
  return (x) => {
    return typeof x === type;
  };
};

isObject = isType('object');

isFunction = isType('function');

concatArr = (arr, cur) => {
  return arr.concat(Array.isArray(cur) ? cur : [cur]);
};

flatArray = (arr) => {
  return arr.reduce(concatArr, []);
};

flatObject = (o) => {
  var key, res;
  res = {};
  for (key in o) {
    if ((o[key] != null) && o.hasOwnProperty(key)) {
      if ((isObject(o[key])) && (!Array.isArray(o[key]))) {
        Object.assign(res, flatObject(o[key]));
      } else if (res[key] == null) {
        res[key] = o[key];
      }
    }
  }
  return res;
};

identity = (x) => {
  return x;
};

None = () => {
  return void 0;
};

isSymmetry = (f) => {
  return (...args) => {
    var l, r;
    l = f(...args);
    r = f(...args.reverse());
    return l === r;
  };
};

isIterable = (x) => {
  return isObject(x) && x[Symbol.iterator];
};

getIterator = (x) => {
  return x[Symbol.iterator]();
};

isMultiIterable = (x) => {
  return isIterable(x) && !isSymmetry(getIterator)(x);
};

mapList = (func) => {
  return function*(list) {
    var item, results, x;
    results = [];
    for (item of list) {
      x = func(list);
      if (isIterable(x)) {
        results.push((yield) * x);
      } else {
        results.push((yield x));
      }
    }
    return results;
  };
};

// M constructs a Monad wrapping a deferred function using Promise
// M(f) is lazy and reinvokable just like a plain function
// with .then and .catch methods like a Promise
M = (() => {
  var handler, reject;
  handler = function(onFulfilled, onRejected) {
    if (!isFunction(onFulfilled)) {
      onFulfilled = null;
    }
    if (!isFunction(onRejected)) {
      onRejected = null;
    }
    if (onFulfilled || onRejected) {
      this.deferreds.push({onFulfilled, onRejected});
    }
    return this;
  };
  reject = function(onRejected) {
    return this.then(null, onRejected);
  };
  return (f) => {
    var _t, deferreds, r;
    if (!isFunction(f)) {
      _t = f;
      f = () => {
        return _t;
      };
    }
    deferreds = [];
    r = function(...args) {
      var d, j, len, p;
      // everytime when r is called,
      // we new a Promise and append every deferreds to it,
      // so r is reinvokable
      p = Promise.resolve().then(() => {
        return f(...args);
      });
      for (j = 0, len = deferreds.length; j < len; j++) {
        d = deferreds[j];
        p = p.then(d.onFulfilled, d.onRejected);
      }
      deferreds = null;
      return p;
    };
    r.deferreds = deferreds;
    return Object.assign(r, {
      // since M(f) is just a function and
      // Promise.prototype.then will lift function to Promise, leaving Promise untouched.
      // we use .then alias for both .map and .bind in a typical Monad
      then: handler.bind(r),
      catch: reject.bind(r)
    });
  };
})();

bindObject = (o, name) => {
  return o[name].bind(o);
};

allPromise = bindObject(Promise, 'all');

racePromise = bindObject(Promise, 'race');

invokeAsync = (func) => {
  return async function(...args) {
    return (await func(...args));
  };
};

expandApply = (func) => {
  return (arr) => {
    return func(...arr);
  };
};

mapArr = (func) => {
  return (arr) => {
    return arr.map(func);
  };
};

zipApplyArr = (a1) => {
  return (a2) => {
    return a1.map((f, i) => {
      return f(a2[i]);
    });
  };
};

invokePromises = (predicate) => {
  return (funcs) => {
    var fz, g;
    g = (f) => {
      return expandApply(invokeAsync(f));
    };
    fz = zipApplyArr(mapArr(g)(funcs));
    return (arr) => {
      return predicate(fz(arr));
    };
  };
};

allAwait = invokePromises(allPromise);

raceAwait = invokePromises(racePromise);

apply = (func) => {
  var f;
  f = expandApply(invokeAsync(func));
  return (mapFunc) => {
    return mapFunc(f);
  };
};

makeFrame = (keys) => {
  return (values) => {
    var o;
    o = {};
    keys.forEach((key, i) => {
      if (values[i] !== void 0) {
        return o[key] = values[i];
      }
    });
    return o;
  };
};

firstElement = (iterable) => {
  return iterable[Symbol.iterator]().next().value;
};

pall = (fn) => {
  return (items) => {
    return allPromise(mapArr(fn)(items));
  };
};

pushMap = (map) => {
  return (item) => {
    return (key) => {
      var c;
      c = map.get(key);
      if (c == null) {
        c = [];
      }
      c.push(item);
      return map.set(key, c);
    };
  };
};

delay = (timeout) => {
  return () => {
    return new Promise((resolve) => {
      return setTimeout((() => {
        return resolve(timeout);
      }), timeout);
    });
  };
};

deadline = (timeout) => {
  return () => {
    return new Promise((resolve, reject) => {
      return setTimeout((() => {
        return reject(timeout);
      }), timeout);
    });
  };
};

retry = (f) => {
  return (count = 1) => {
    return (...args) => {
      var g;
      return (g = (e) => {
        if (count--) {
          return Promise.resolve(f(...args)).catch(g);
        } else {
          return Promise.reject(e);
        }
      })(void 0);
    };
  };
};

logLevel = 2;

genLog = ((logLevel) => {
  return (level) => {
    return (func) => {
      if (logLevel > level) {
        return func;
      } else {
        return None;
      }
    };
  };
})(logLevel);

logInfo = genLog(1)(bindObject(console, 'log'));

logError = genLog(-1)(bindObject(console, 'error'));

getFullPath = (directory) => {
  var p, path;
  path = require('path');
  p = path.join(process.cwd(), directory);
  return (name) => {
    return path.join(p, name);
  };
};

module.exports = {concatArr, flatArray, flatObject, identity, None, M, invokeAsync, allAwait, raceAwait, delay, deadline, retry, makeFrame, firstElement, pall, pushMap, logInfo, logError, getFullPath};

//# sourceMappingURL=common.js.map
